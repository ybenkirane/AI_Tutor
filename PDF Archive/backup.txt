import openai, os, json, re, random

openai.api_key = os.environ["OPENAI_API_KEY"]


Industry = "Hedge Fund"
Position = "Quantitative Analyst"
Company = "Company"

# Topics = ["Logic", "Puzzles", "Probability", "Recursion", "Statistics", "Arbitrage", "Exotic and Structured Products", 
#           "Finance", "Trading", "Algorithms", "Riddles", "Market Risk Economics", "Game Theory", "Mathematics", "Fermi Estimation Problem", 
#           "Financial Engineering", "Time Series Analysis", "Artifical Intelligence"]

Topics = ["Probability and Statistics: Examples of which include but are not limited to Probability Distrubutions, Bayesian Statistics, Regression Analysis, Hypothesis testing, Confidence Intervals, Central Limit Theorem, and Monte Carlo Methods",
        "Linear Algebra: Examples of which include but are not limited to Matrix Operations, Eigenvectors, Eigenvalues, Singular Value Decomposition, Principal Component Analysis",
        "Calculus and Differential Equations: Examples of which include but are not limited to Partial Derivatives, Multivariable Optimization, Integration Techniques, Ordinary and Partial Differential Equations",
        "Stochastic Calculus: Examples of which include but are not limited to Brownian Motion, Ito's Lemma, Stochastic Differential Equations, Girsanov's Theorem",
        "Financial Mathematics: Examples of which include but are not limited to Time Value of Money, Discounted Cash Flow, Yield Curve and Interest Rate Models, Black-Scholes-Merton Option Pricing Model, Greeks (Delta, Gamma, Vega, etc.)",
        "Portfolio Theory and Optimization: Examples of which include but are not limited to Modern Portfolio Theory, Efficient Frontier, Capital Asset Pricing Model (CAPM), Black-Litterman Model, Risk Metrics (Value at Risk, Conditional Value at Risk, etc.)",
        "Exotic and Structured Products: Examples of which include but are not limited to Barrier options, Asian options, Lookback options, Convertible bonds, Mortgage-backed securities ",
        "Algorithmic Trading and Market Microstructure: Examples of which include but are not limited to Order Book Dynamics, High-Frequency Trading Strategies, Market Making and Inventory Management, Transaction Costs and Slippage, Market Impact Models",
        "Machine Learning and Data Science: Examples of which include but are not limited to Supervised and Unsupervised Learning, Neural Networks and Deep Learning, Decision Trees and Random Forests, Support Vector Machines, Clustering and Dimensionality Reduction Techniques",
        "Time Series Analysis and Econometrics: Examples of which include but are not limited to Autoregressive Integrated Moving Average (ARIMA) Models, GARCH Models, Cointegration and Error Correction Models, Kalman Filters and State Space Models, Granger Causality Tests",
        "Mathematical Puzzles and Riddles: Examples of which include but are not limited to Fermi Estimation Problems, Combinatorial Problems, Graph Theory Problems, Number Theory Problems, Game Theory Problems",
        "Programming and Software Skills, Examples of which include but are not limited to Programming Languages (Python, C++, R, MATLAB), Data Manipulation and Analysis Libraries (NumPy, Pandas, TensorFlow), Version Control Systems (git), Database Management Systems (SQL, NoSQL), APIs and Web Scraping Techniques",
        "Optimization and Numerical Methods: Examples of which include but are not limited to Linear Programming and Integer Programming, Convex Optimization, Gradient Descent and Newton's Method, Finite Difference Methods, Monte Carlo Simulation and Variance Reduction Techniques",
        "Risk Management: Examples of which include but are not limited to Credit Risk and Counterparty Risk, Liquidity Risk, Operational Risk, Enterprise Risk Management Frameworks, Stress Testing and Scenario Analysis",
        "Miscellaneous Mathematical Topics: Examples of which include but are not limited to Binomial Theorem, Taylor Series and Approximations, Fourier Analysis, Laplace Analysis, Laplace and Fourier Transforms, Graph Theory and Network Analysis"]

# Topics = ["Molecular Biophysics: Examples of which include but are not limited to Molecular Dynamics Simulations, Protein Folding, Ligand-Receptor Interactions, Membrane Biophysics, and Single-Molecule Techniques",
# "Structural Biology: Examples of which include but are not limited to X-ray Crystallography, Nuclear Magnetic Resonance (NMR) Spectroscopy, Cryo-Electron Microscopy (Cryo-EM), and Small-Angle X-ray Scattering (SAXS)",
# "Bioenergetics and Thermodynamics: Examples of which include but are not limited to Enzyme Kinetics, Metabolic Pathways, Photosynthesis, Bioenergetics, and Free Energy Calculations",
# "Cellular and Systems Biophysics: Examples of which include but are not limited to Cell Mechanics, Cellular Signaling, Biophysical Modeling of Cellular Systems, and Tissue Biophysics",
# "Neurobiophysics: Examples of which include but are not limited to Ion Channels, Action Potentials, Neural Networks, Synaptic Transmission, and Neuroimaging Techniques",
# "Biopolymers and Biomaterials: Examples of which include but are not limited to DNA, RNA, Proteins, Polysaccharides, and Extracellular Matrix Components, as well as their Mechanical, Thermal, and Optical Properties",
# "Quantitative Biology and Bioinformatics: Examples of which include but are not limited to Genomics, Transcriptomics, Proteomics, Metabolomics, Systems Biology, and Computational Biology",
# "Biophysical Techniques and Instrumentation: Examples of which include but are not limited to Fluorescence Spectroscopy, Optical Tweezers, Atomic Force Microscopy (AFM), Surface Plasmon Resonance (SPR), and Patch-Clamp Techniques",
# "Physics of Living Systems: Examples of which include but are not limited to Soft Matter Physics, Active Matter, Collective Behavior and Swarming, and the Emergence of Complexity in Biological Systems",
# "Statistical Mechanics and Stochastic Processes in Biology: Examples of which include but are not limited to Random Walks, Master Equations, Langevin Dynamics, and Stochastic Simulation Algorithms",
# "Biomechanics and Mechanobiology: Examples of which include but are not limited to Cellular and Tissue Mechanics, Force Sensing and Transduction, Mechanotransduction, and Biomechanics at the Organism Level",
# "Nanotechnology and Biophysics: Examples of which include but are not limited to Nanoscale Biophysical Phenomena, Nanoparticles and Nanodevices in Biology, and Biological Applications of Nanotechnology",
# "Computational and Theoretical Biophysics: Examples of which include but are not limited to Molecular Modeling, Coarse-Grained Models, Computational Systems Biology, and Theoretical Approaches to Biophysical Phenomena",
# "Quantum Biology: Examples of which include but are not limited to Photosynthesis and Light-Harvesting Complexes, Enzymatic Reactions, Electron and Proton Transfer in Biological Systems, and Quantum Effects in Biological Processes",
# "Biophysics of Disease and Drug Design: Examples of which include but are not limited to Protein Misfolding and Aggregation, Viral Biophysics, Biophysical Approaches to Drug Design, and Targeting Biophysical Mechanisms in Disease"]

Puzzles = ["Logic Puzzle: Examples include The Knights and Knaves Problems and The Two-Envelope Paradox", 
           "Combinatorial Puzzle: Examples include The Coin Flipping Problem, The Handshake Problem, The Blue Eyes Problem, and The Hat Puzzle", 
           "Probability Puzzle: Examples include The Monty Hall Problem and The Birthday Paradox", 
           "Lateral Thinking Puzzle: Examples include The 100 Prisoners and a Light Bulb Puzzle and The Burning Ropes Problem", 
           "Geometry and Visual Puzzles: Examples include The Three Ants on a Triangle and The Water Jug Problem", 
           "Number Theory and Algebra Puzzles: Examples include the 3-5-7 Problem and the Missing Number Problem", 
           "Gamer Theory Puzzles: Examples Include The Prisoner's Dilemma and the Nim Game"]

#SHUFFLE THE LIST OF EXAMPLES AS THE FIRST ONE IS MOST LIKELY TO BE CHOSEN BY THE MODEL


difficultySelectionList_Topics = [0, 0, 1, 0] 
difficultySelectionList_Puzzles = [1, 1, 1, 1]

n_topics = sum(difficultySelectionList_Topics)
n_puzzles = sum(difficultySelectionList_Puzzles)


def remove_control_characters(s):
    return re.sub(r'[\x00-\x1F\x7F]', '', s)

# def call_gpt(prompt, user_messages=[], model="gpt-4"):
#     messages = [
#         {"role": "system", "content": f"""You are a top-level {Industry} interviewer. You are interviewing a candidate for the position of {Position}. 
#         Consider this prompt: """},
#     ]
    
#     for message in user_messages:
#         messages.append({"role": "user", "content": message})

#     messages.append({"role": "user", "content": prompt})

#     response = openai.ChatCompletion.create(
#         model=model,
#         messages=messages,
#         max_tokens=100,
#         n=1,
#         stop=None,
#         temperature=0.5,
#         stream=True,
#     )

#     message = response['choices'][0]['message']['content']
#     return message.strip()

"""
    GENERATING PRE, MAIN, AND POST INTERVIEW QUESTIONS:
        Generating a complete list of questions for the pre, main, and post interview
        stages in JSON formatted blocks to easily extract type, question, and grading rubric. 
        Must be streamed to ensure reasonable response times.
        Each list is saved to a JSON file for later use in which the questions can be split during interview and asked individually
        to save token usage.
"""

def gpt_Q_Gen(question_prompt, title):
    
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[
        {"role": "system", "content": f"""You are a top-level {Industry} interviewer. You are interviewing a candidate for the position of {Position}. 
        Consider this prompt: """},
        {"role": "user", "content": question_prompt},
        ],
        max_tokens=1000,
        n=1,
        stop=None,
        temperature=0.5,
        stream=True,
    )

    #Creating the empty text file.
    with open(f"{title}.json", "a", encoding="utf-8") as f:
        for chunk in response: 
            word = chunk["choices"][0].get("delta", {}).get("content")
            if word is not None:
                print(word, end='', flush=True)
                f.write(word)
                f.flush()


def preInterview_Generation():
        
    preInterview_Prompt = f"""Generate a list of questions for the start of the interview. These should be simple questions regarding the candidate's cultural background,
    hobbies, interests, risks they've taken, weaknesses, failures, personal icons and heros, and other personal information. Phrase them in a way that relates to the position and the company's culture.
    You may relate them to your own experiences as a top-level {Industry} analyst. Try to empathize with the candidate and make them feel comfortable.
    Provide them in a JSON format, presenting the "Topic" and "Question".
    Provide 2 questions.
    """
    gpt_Q_Gen(preInterview_Prompt, title="preInterview")


def mainInterview_Generation():
    # Number of questions per difficulty level - Easy, Medium, Hard, Very Hard

    if n_topics >= len(Topics):
        randomTopics = random.choices(Topics, k=len(Topics))
    else: 
        randomTopics = random.choices(Topics, k=n_topics)
    
    print(randomTopics)

    if n_puzzles >= len(Puzzles):
        randomPuzzles = random.choices(Puzzles, k=len(Puzzles))
    else: 
        randomPuzzles = random.choices(Puzzles, k=n_puzzles)
    
    print(randomPuzzles)

    jsonQuestionFormat = """
    Format Example: 

            {
                "questions": [
                    {
                    "Topic": "Topic",
                    "Difficulty": "Difficulty",
                    "Question": "Question"
                    },
                    {
                    "Topic": "Topic",
                    "Difficulty": "Difficulty",
                    "Question": "Question"
                    }
                    ...
                ]
            }
    """

    mainInterview_TopicPrompt = f"""Generate a list of problems in ascending difficulty relating to these topics: {randomTopics}.
    Provide them in a JSON format, presenting the "Topic", "Difficulty", "Question".
    The difficulty levels are "Easy", "Medium", "Hard", "Very Hard". The "Easy" option should be a fairly straightforward question requiring 1-2 steps to solve or answer. The "Medium" option should begin involving more complex logic. The "Hard" and "Very Hard" options must be extremely difficult, even for a PhD-level graduate. 
    Provide {difficultySelectionList_Topics[0]} Easy question(s), {difficultySelectionList_Topics[1]} Medium Question(s), {difficultySelectionList_Topics[2]} Hard Question(s), and {difficultySelectionList_Topics[3]} Very Hard question(s). 
    There should be a total of {n_topics} questions.Make sure they are intricate and well-thought-out. 
    If applicable, equations should be in LaTeX. You must follow the format: """ + jsonQuestionFormat
    
    gpt_Q_Gen(mainInterview_TopicPrompt, title="mainInterviewTopic")

    # mainInterview_PuzzlePrompt = f"""Generate a list of Brain Teaser Puzzle problems in ascending difficulty relating to these topics: {randomPuzzles}.
    # Provide them in a JSON format, presenting the "Topic", "Difficulty", "Question".
    # The difficulty levels are "Easy", "Medium", "Hard", "Very Hard". The "Hard" and "Very Hard" options must be extremely difficult, even for a PhD-level graduate. 
    # Provide {difficultySelectionList_Puzzles[0]} Easy Puzzle, {difficultySelectionList_Puzzles[1]} Medium Questions, {difficultySelectionList_Puzzles[2]} Hard Question, and {difficultySelectionList_Puzzles[3]} Very Hard question. 
    # Make sure they are intricate and well-thought-out. You must follow the format: """ + jsonQuestionFormat
    
    # gpt_Q_Gen(mainInterview_PuzzlePrompt, title="mainInterviewPuzzle")

def postInterview_Generation():

    postInterview_Prompt = f"""Generate a list of brain teasers in ascending difficulty relating to these topics: 
    (logic, puzzles, probability, statistics, financial, trading, game theory, estimation, mathematics, or physics). 
    Provide them in a JSON format, presenting the "Topic", "Difficulty", "Question".
    The difficulty may be stated as "Easy", "Medium", "Hard", "Very Hard". Provide approximately 3 questions per difficulty level.
    """
    gpt_Q_Gen(postInterview_Prompt, title="postInterview")

"""
Solution and Rubric Generation:
    Take individual objects/questions from the Interview Questions JSON file and generate a solution and grading rubric for each. 
"""

def rubricGenerator(iteration):
    with open(f"mainInterviewTopic.json", "r") as f:
        dataQuestion = json.load(f)
    
    question = dataQuestion["questions"][iteration]["Question"]

    jsonSolutionFormat = """
        Format Example: 

                {
                    "solution": [
                        {
                        "Question": "Question Number",
                        "Answer": " Complete Answer to the first question with structured reasoning and detailed steps."
                        }
                    ]
                }
        """
    # FORGOT WE WERE ITERATING THROUGH THE QUESTIONS IN THE JSON FILE --> NEED TO EITHER BE OK WITH MULTIPLE OBJECT SOLUTION IN ONE JSON FILE OR CREATE MULTIPLE JSON SOLUTION FILES..
    solution_Prompt = f"""Generate a solution to the following question:{question}. Provide a highly detailed solution that covers all possible cases, discusses the theory behind 
    the solution and the reasoning behind each step. It must be clear and consise.
    Return the solution in a JSON format, presenting the "Question Number {iteration}", "Solution". 
    If applicable, equations should be in LaTeX. You must folow this format: """ + jsonSolutionFormat
    gpt_Q_Gen(solution_Prompt, title=f"solution{iteration}")

    with open(f"solution{iteration}.json", "r") as f:
        file_content = f.read()
        cleaned_content = remove_control_characters(file_content)
        dataSolution = json.loads(cleaned_content)

    solution = dataSolution["solution"][0]["Answer"]

    jsonRubricFormat = """

                {
                    "rubric": [
                        {
                        "Question": "Question Number",
                        "Rubric": " Complete Rubric to the question based on the example solution provided."
                        }
                    ]
                }
        """

    # Rubric Generation
    rubric_Prompt = f"""Generate a rubric on how to grade to the following problem: {question}. Make use of on the generated example solution: {solution}. 
    The rubric must be highly critical and structured, such that the interviewer may easily identify flaws in the candidate's thought process and solution. 
    It is critical that the rubric presents exactly how each point can be acquired and what differentiates each point acquired. 
    The marks / points must be integer values that sum up to a total score. 
    A correct and structured thought process is more important than achieving the correct final solution. The rubric will be used to grade the candidate's answer.
    This rubric must identify how each part of the solution will be graded, how to allocate marks, and how to identify the quality of the answer.
    Return the solution in a JSON format, presenting the "Question Number {iteration}", "Rubric". 
    If applicable, equations should be in LaTeX. You must folow this format: """ + jsonRubricFormat
    gpt_Q_Gen(rubric_Prompt, title=f"rubric{iteration}")

"""
Hint Generation:
"""


"""
Grading Candidate's Solution:
"""

def gradeCandidate(answer, iteration):
    with open(f"rubric{iteration}.json", "r") as f:
        file_content = f.read()
        cleaned_content = remove_control_characters(file_content)
        dataRubric = json.loads(cleaned_content)
    
    with open(f"mainInterviewTopic.json", "r") as f:
        dataQuestion = json.load(f)
    
    question = dataQuestion["questions"][iteration]["Question"]
    rubric = dataRubric["rubric"][0]["Rubric"]

    jsonGradingFormat = """
                {
                    "grade": [
                        {
                        "Solution": "Solution Number",
                        "Remarks": "Complete Remarks to the solution provided by the candidate. Going over which points were achieved and which were not.",
                        "Score": "(Achieved Score) / (Maximum Score)"
                        }
                    ]
                }
    """

    grading_Prompt = f"""The question asked to the candidate was: {question}. 
    Based on the rubric: {rubric}, please grade the candidate's solution: {answer}.
    Return the grading output in a JSON format, presenting the "Solution Number {iteration}", "Remarks", and "Score". 
    You must folow this format: """ + jsonGradingFormat

    gpt_Q_Gen(grading_Prompt, title=f"score{iteration}")    

    #Now we extract the score from the JSON output.
    with open(f"score{iteration}.json", "r") as f:
        file_content = f.read()
        cleaned_content = remove_control_characters(file_content)
        dataScore = json.loads(cleaned_content)
    
    score = dataScore["grade"][0]["Score"]
    return score

def candidateInterview():
    for n in range(0, n_topics):
        with open(f"mainInterviewTopic.json", "r") as f:
            data = json.load(f)
        question = data["questions"][n]["Question"]

        print(question)
        user_input = ""
        solution = ""
        while user_input.lower() != "done":
            user_input = input("\n\nEnter your solution. Clearly walk through your entire thought process. After submitting, type in 'done': ")

            if user_input.lower() != "done":
                solution += user_input + "\n"

        score = gradeCandidate(solution, n)
        with open(f"candidateSolution{n}.txt", "w") as f:
            f.write(solution)

        print(f"Your score to question {n} is: {score}")

def main():
    import pdfGenerator

    mainInterview_Generation()
    for questions in range(0, n_topics):
        rubricGenerator(questions)

    candidateInterview()
    pdfGenerator()

if __name__ == "__main__":
    main()